# Kubernetes

- In AWS, there are VPC level resources and non vpc level resources
- VPC level resources i.e. attached to VPC are:
  - subnet
  - security group
  - Load balancer
- E.g. for non vpc level resources is Route53
- Even in K8s, we have namespace level and non-namespace level resources
- Few resources are attached to the namespace such as project level or cluster level resources and few are not such as nodes
- We can get the list of resources: `kubectl api-resources`

## Pods

- Pods are smallest deployment units in K8s
- Every resource in Kubernetes has:

```yaml
apiVersion: v1
kind: Pod # What kind of resource is it?
metadata:
  name: nginx # Name of the pod
  namespace: roboshop
```

- All the other configuration information is specified under spec
- For e.g. when we run nginx as a docker container: `docker run -d -p 80:8080 nginx:latest`
  - Here `-p 80:8080` information is specifed under spec
- We use K8s to run the images but not docker, therefore we need `manifest.yaml` files to run pods

  `01-pod.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod # What kind of resource is it?
  metadata:
    name: nginx # Name of the pod
    namespace: roboshop
  spec:
    containers:
    - name: simple-pod
      image: nginx:1.14.2
      ports:
      - containerPort: 80
  ```

**How to create pod?**

- First ensure that roboshop namespace is present
- Then run `kubectl apply -f 01-pod.yaml`
- To get the list of pods in roboshop namespace: `kubectl get pods -n roboshop`

**How to login to pod?**

- `kubectl exec -it <name-of-the-pod> -n roboshop -- bash`

### Difference between Pods and container

- 1 pod can have multiple containers
- All containers inside pod share same storage and n/w

**Why Kubernetes offers multi-containers?**

- In ELK, we installed an agent such as filebeat on the component server which monitors `/var/log/messages` file and pushing the messages to ELK Cluster
- Similarly inside Pod, we can run multiple containers. For e.g. 1 NGiNX pod, 1 filebeat pod
- NGiNXs stores the logs to `/var/log/nginx/access.log` file and as both the containers are inside the same pod, filebeat can access this file as they share common storage and push the messages to ELK cluster
- Here **filebeat** container is referred as **side car containers**
- Multi containers can be used in:
  - side car
  - proxy patterns
  - init containers

**How can we create multiple containers inside a pod?**

  `02-multi-container.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod # What kind of resource is it?
  metadata:
    name: nginx # Name of the pod
    namespace: roboshop
  spec:
    containers:
    - name: nginx
      image: nginx
    - name: sidecar
      image: almalinux:8
      command: ["sleep", "200"]
  ```

- As almalinux doesn't have a command to run for infinite time, we need to explicity specify a command on our own
- The pods can created with the command: `kubectl apply -f 02-multi-container.yaml`
- Once they are created, we can login in to the pods using: `kubectl exec -it <name-of-the-pod> -c <name-of-the-container> -- bash`
- As both these containers share the same network, we can run `curl localhost` to see the default homepage that is served by NGiNX
- To access the logs generated by NGiNX, we need to perform **Volume mapping**

**How to add labels to the pods?**

  `03-labels.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: nginx # Name of the pod
    namespace: roboshop
    labels:
      environment: production
      app: nginx
  spec:
    containers:
    - name: nginx
      image: nginx
    - name: sidecar
      image: almalinux:8
      command: ["sleep", "200"]
  ```

- Labels are used in selectors and it has some functional advantage apart from filtering
- Like `docker inspect`, we can inspect a pod using: `kubectl describe pod <name-of-the-pod>`

**Difference between Labels and annotations:**

- labels can't have special char in key names, annotations can have
- lables key have some length restrictions, annotations length can be more than lables
- labels are used for selecting internal kubernetes resources selectors where as annotations are used in selecting external resources

  `04-annotations.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: nginx # Name of the pod
    namespace: roboshop
    labels:
      environment: production
      app: nginx
    annotations:
      com.project.name: roboshop
      com.component.name: frontend
  spec:
    containers:
    - name: nginx
      image: nginx
    - name: sidecar
      image: almalinux:8
      command: ["sleep", "200"]
  ```

- In VM, the resources are blocked when we create and run it where as with Docker containers, it can dynamically consume te system resources
- But the disadvantage with dynamic consumption is that, it can also end up occupying complete system resources based on the task it is performing
- To overcome this, we can set a limit i.e. soft limit to the resource that it can consume using `requests` and hard limits using `limits`
- To ensure that the resources are not blocking the memory and ram, K8s monitors the pods so they do not endup consuming more resources than mentioned.

  `05-resources.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: resources
  spec:
    containers:
    - name: nginx
      image: nginx
      resources:
        requests: # soft limit
          memory: "64Mi"
          cpu: "250m"
        limits: # hard limit i.e. max. limit
          memory: "128Mi"
          cpu: "500m"
  ```

- 1 CPU is 1000 milli cores, 250m -> 0.25 CPU

### Image Pull Policy

- By default K8s only pulls the image from docker hub at the time of creation of the pod
- If there are any updates to the image, it will not fetch them by default
- To fetch the updates, we need to set: `imagePullPolicy: Always`

  `05-resources.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: resources
  spec:
    containers:
    - name: nginx
      image: nginx
      imagePullPolicy: Always
      resources:
        requests: # soft limit
          memory: "64Mi"
          cpu: "250m"
        limits: # hard limit i.e. max. limit
          memory: "128Mi"
          cpu: "500m"
  ```

### Environment Variables

- Defining environment variables to access inside the container

`06-environment.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: resources
  spec:
    containers:
    - name: nginx
      image: nginx
      env:
      - name: DEMO
        value: "Hello Environment variable"
  ```

## Config map

- It is used for keeping the configuration information separate from the container as its a best practice

  `07-configmap.yaml`

  ```yaml
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: course-config
  data:
    COURSE: DevOps
    DURATION: 120HRS
    TRAINER: SIVAKUMAR
  ```

- To list all the configmaps: `kubectl get configmaps`
- To inspect the config map: `kubectl describe configmap <name-of-the-configmap>`
- Once the configuration is created, we can attach it to a pod by fetching the values from a configmap using:

  ```yaml
  - name: COURSE
    valueFrom:
      configMapKeyRef:
        name: course-config
        key: COURSE
  ```

  `08-config-pod.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: config-pod
  spec:
    containers:
    - name: config-pod
      image: nginx
      env:
      - name: COURSE
        valueFrom:
          configMapKeyRef:
            name: course-config
            key: COURSE
      - name: PERSON
        valueFrom:
          configMapKeyRef:
            name: course-config
            key: TRAINER
      - name: DURATION
        valueFrom:
          configMapKeyRef:
            name: course-config
            key: DURATION
  ```

### How to import all configuration variables from configmap

- Instead of hardcoding all the values and assigning them to variables in the pod manifest, we can import all of them at one go
- This way we can have the pod manifest file as small as possible

  `09-import-all.yaml`

  ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: import-all
    spec:
      containers:
      - name: import-all
        image: nginx
        envFrom:
        - configMapRef:
          name: course-config
  ```

## Secret

- For storing confidential information
- The information is base64 encoded
- We can define multiple resources in the same yaml file with `---` separated

  `10-secret.yaml`

  ```yaml
  apiVersion: v1
  kind: Secret
  metadata:
    name: secret-basic-auth
  data:
    username: c2l2YWt1bWFyCg==
    password: YWJjMTIzCg==
  ---
  apiVersion: v1
  kind: Pod
  metadata:
    name: secret-pod
  spec:
    containers:
    - name: secret-pod
      image: nginx
      envFrom:
      - secretRef:
          name: secret-basic-auth
  ```

- How can we expose the deployed pods to the external users? **Services**

## Services

- There are multiple advantages of using a service
  1. To expose the application to outside world
  2. To balance the load -> at the time of deployment and replicaset
  3. Serves as a **Service Mesh** as well i.e. even though the IP address changes, it gets mapped to the DNS
- There are 3 kinds of services
  1. Cluster IP: Internal to cluster, not exposed to outside world, only exposed within the cluster
  2. NodePort
  3. Load Balancer: Only for Cloud related kubernetes
- For NodePort service and Load Balancer service, minikube environment is not sufficient. We need an actual K8s cluster

### Cluster IP

  `services/01-cluster-ip.yaml`

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: nginx
    labels: # These are used for selecting and filtering the pod
      environment: dev
      app: frontend
      project: roboshop
  spec:
    containers:
    - name: nginx
      image: nginx
      ports:
        - containerPort: 80
          name: http-web-svc
  ---
  apiVersion: v1
  kind: Service
  metadata:
    name: nginx-service
  spec:
    # search for pods that matches the given labels and attach to it
    selector:
      environment: dev
      app: frontend
      project: roboshop
    ports:
    - name: name-of-service-port
      protocol: TCP
      port: 80 # this port belongs to service
      targetPort: http-web-svc # this port belongs to container
  ```
